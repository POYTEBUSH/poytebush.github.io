<h4>Introduction</h4>
<p>I have created a game called Rocket Ball for this project and Involves the use of DirectX11 to
    complete many different rendering techniques and styles by passing render data between multiple shaders. The game
    was then improvved to handle physics and collisions to replicate a game similar to Rocket League.</p>
<h4>Player Controls</h4>
<ul>
    <li>
        <p>Player</p>
        <ul>
            <li>
                <p><kbd>W</kbd>&nbsp;Moves the car forwards with a force in relation to its mass</p>
                <p><kbd>A</kbd>&nbsp;Moves the car Left-ways with a force in relation to its mass</p>
                <p><kbd>S</kbd>&nbsp;Moves the car backwards with a force in relation to its mass</p>
                <p><kbd>D</kbd>&nbsp;Moves the car Right-way with a force in relation to its mass</p>
                <p><kbd>Space</kbd>&nbsp;Jump</p>
            </li>
        </ul>
        <p>Camera</p>
        <ul>
            <li>
                <p><kbd>1</kbd>&nbsp;Free camera controlled via the mouse</p>
                <p><kbd>2</kbd>&nbsp;Arena / Spectator Camera</p>
                <p><kbd>3</kbd>&nbsp;Follow Camera that stays behind the player</p>
                <p><kbd>4</kbd>&nbsp;Top Camera above the player</p>
            </li>
        </ul>
        <p>Acceleration</p>
        <ul>
            <li>
                <p><kbd>5</kbd>&nbsp;Move at constant Acceleration</p>
                <p><kbd>6</kbd>&nbsp;move at constant velocity</p>
            </li>
        </ul>
    </li>
</ul>
<h4>The Game</h4>
<p>This game utilises a physics system programmed in C++ using a combination of Mass Aggregate and a rigid body system to simulate a football field with extra features. Each game object in the game is assigned an Appearance (how it looks and its geometry) a Transform (where it is located in world space, its rotation and its scale) and a Particle Model which is used to apply forces and update the position and rotation in relation to them. Each particle model is initialised to have values for its acceleration and velocity along with a pointer to the game objects transform, allowing for the transformation of the object. We also pass into the particle model constructer a collision radius for spherical based collisions, a mass to allow calculation of weight in relation to gravity and a Boolean to specify  whether or not the game object is affected by gravity or not (allows for assets such as the arena to be ignored). In the constructor of this class, I also specify the flow and move type of the object that are both enums. </p>
<code>
    enum FlowType
    {
        NOTSET,
        LAMINAR,
        TURBULENT
    };                   
</code>
<br>
<code>
    enum MoveType
    {
        CONSTACCELL,
        CONSTVEL
    };            
</code>
<p>When the game has a certain FlowType assigned the velocity will slow down with a calculation of drag force in relation to its drag factor and the overall weight of the object. The movement type will specify the calculations for the movement / displacement of the game object each frame in relation to the net force added. At each frame I make sure that all forces are removed and the net force and acceleration are cleared. I use the method AddForce(Vector3D force) which takes in a Vector based force and will push it onto the vector stack, I then call my update for the particle model which firstly will update the momentum and position values to be correct and then assigns a gravity vector if A. it is affected by it and B. if the game objects y position is greater than 0.0f and then if the object is less than 0.05f on the y axis then a resultant force to weight is applied to simulate the effect of the object bouncing. After the gravity and resultant force is applied I then update the net force which is calculated as a vector and uses a for loop to iterate through all values in the forces vector stack and add them to the running total for the net force. This value is then used to calculate the total the acceleration of the object.</p>
<p>If the move at constant acceleration is chosen then the equations S=UT + 0.5 * AT¬2 and V = U + AT which calculate the displacement and change in velocity at each frame respectively.</p>
<p>The value of 0.017 is the time step that allows this calculation to be corresponding with the 60FPS lock that the game is set to. Once these two formulas are calculated I follow up by making the velocity get reduced by the drag factor which allows for the object to progressively slow down until it is fully stationary. 
        When using move forwards at a constant velocity I simply use the method of taking the current position and adding the velocity + time step. 
        </p>
<h4>Collisions</h4>        
<p>I use two different collision calculations for my game, one is a Sphere to sphere and the other is a Sphere to AABB (Axis aligned bounding Box). The sphere to sphere calculation takes into account the centre position of both spheres and their radii; The calculation simply aim to check whether or not the distance between the two centre points is smaller than the radius of the sphere.</p>
<p>When a game object hits the bounds of the arena the object will bound off the wall with a velocity that is the dot product of the original velocity flipped and the collision normal of the wall:
        object->SetVelocity(object->GetVelocity().DotProduct(Vector3D(-1.0f, 0.0f, 0.0f)));
        The ball and the player also collide where the velocity of the objects are set to be their current velocity – the momentum of the collider / the current objects mass.
        </p>
<p>My particle system works by instantiating a set number of game objects into a vector stack and then applying a similar force to them all from an emitter point, Using object pooling I am able to move the objects with the forces and then when they hit the specified max height they are moved back to the emmiter point to move again.
<br><code> ParticleSystem(int NumOfParticles, GameObject* Particle, Vector3D startPos, float maxHeight);</code>
        The designer is able to pass in any already instantiated game object to the particle system along with the number of objects in the system and their max height, they can also choose between a spray effect and a fountain effect where the particles will move in a different way using the 
        <br><code>void SetParticleSystemEffect(ParticleSystemType type) { mSystemType = type; };</code>
        Due to all of the particles being smaller game objects without colliders they are drawn in the same way to the screen and updated also.
</p>        