[
    {
        "Title": "Final Year Project - Beliveability of AI agents",
        "Subtitle": "Exploring what approaches can be applied to AI Agents to make them appear more human.",
        "Thumbnail": "AIBase.jpg",
        "ContentGallery" : "",
        "ContentText": "<h4>Introduction</h4> <p>Artificial Intelligence in computer games is used to enhance the gameplay through increasing the population and interaction it offers to the players. This study aims to look at the approaches taken to improve Artificial intelligent (AI) human based agents such as troops in a military simulator or NPC’s in MMORPG’s. The aforementioned AI agents must follow human-like actions and approaches to issues to make them appear less robotic and pre-calculated. </p> <p> One major issue with AI Agents is that due to the complexity of their actions they are often pre-programmed to perform actions in the best possible way, this however to the human eye may not seem the smartest of options. An example of this is in path-finding where the AI agent will choose to take the shortest route without any application to forward which in comparison a human might opt to cut corners or take a longer route which in hindsight might be safer. The aim of my research is to analyse and compare different approaches made in the games industry to improve the appearance of AI agents with the aim to make them appear more like human controlled characters and less out of place </p> <p> My aim for this study is to analyse multiple techniques in order to create an AI system to play <a href='https://en.wikipedia.org/wiki/AssaultCube'>Assaulty Cube</a> which is a Free Open Source FPS game built on the <a href='http://cubeengine.com/cube.php4'>CUBE Engine</a>. </p> <p> This study is currently on-going and will be completed along side documentation and a thesis report. </p>",
        "Categories": "c++,ai,visualstudio"
    },
    {
        "Title": "Low Level Programming",
        "Subtitle": "Optimisation of a simple raytracing application with multiple low level techniques.",
        "Thumbnail": "raytracersphere.png",
        "ContentGallery" : "img~\\Thumbnails\\llfigure1.PNG,img~\\Thumbnails\\llfigure2.PNG,img~\\Thumbnails\\llfigure3.PNG,img~\\Thumbnails\\llfigure4.PNG,img~\\Thumbnails\\llfigure5.PNG,img~\\Thumbnails\\llfigure6.PNG,img~\\Thumbnails\\llfigure7.PNG,img~\\Thumbnails\\llfigure8.PNG,img~\\Thumbnails\\llfigure9.PNG",
        "ContentText": "<h4>Optimisations and Tabulated Data</h4> <h5>Start to End Frame Times</h5> <p>Multiple optimisations have been made to the code base of the ray tracing application to increase the speed of render. As you can see from the data shown below, in tests using two different systems with different CPUs. Both systems use 16GB of RAM and are running on a local Hard Drive. The graph [Figure 1] shows the increase overall from the starting code to the final product when run, the improvements on the i7 4770k lead to an improvement of 36.5 times faster, with the Xeon running 30.4 times faster also. </p> <h5>O0 and O2 Optimisation Levels</h5> <p> When utilising the C++ compiler settings for a release of the ray tracing applications two options were used and tested. O0 offers no optimisation improvements and O2 offers improvements to the compile which favours speed over the size of the final solution. Regardless of the system that is being used, it can be noted that using O2 compiler settings will make the system between 7-10 times faster (i7 at 9.2 times and Xeon at 7.3 times faster). </p> <h5>Floating Point Precision Optimisations</h5> <p> Using the floating point precision level of fast over the default precise as shown in Figure 4 improves the speed of the fully threaded application by around 0.2seconds for each frame, This also meant that there was no reason code any improved solution such as (Anon., n.d.) where  the speed was either the same or slightly slower. </p> <h5>Threading Optimisations</h5> <p> reading the application allowed for the system to utilise all of its resources on rendering the images, the application automatically calculates the number of threads that are available to the application and divides the screen up into that amount of chunks, this allows for each section of the render to be calculated on a different thread improving the speed drastically. The graph shown in [Figure 4] shows the vast increase in render speeds when threading is enabled, The Xeon was able to render 2.4 times faster when using all 4 cores available and the i7 3.2 times faster when using all 8 cores. It should be noticed that both CPUs architecture are over 5 years old and newer CPUs will be able to offer far improved speeds. It is also noted that the number of cores will not exponentially improve the speed of the application. .</p> <h5>Data Structure Optimisations</h5> <p>One of the optimisations that were performed on the application was to develop a templated Linked List, this allowed easier removal and adding to the list when compared to the pre-existing use of a vector, this structure was used to hold all Sphere data that was loaded in. The sphere data, in the beginning, was cleared and repopulated each frame, this allowed for a reduction in each frame time as the spheres didn’t require a recreation. The largest optimisation to the data structure, however, was re-using the Vec3f used to contain the image data, originally this data source was reinitialised each frame and then deleted, this was not necessary as once the image had been exported to a file it was no longer needed in the application, rather than deleting and recreating a clean object it was simply improved to just overwrite the original one, moving the initialisation of the object to the constructor.</p> <p>The image Vec3f was also set up as a float, when using a 1080p image it would be 24Mb (24883200 bytes) in memory size, this image object is used throughout the app to hold the colour data that is then output to a file, when the file is output each value was converted to an unsigned char (max value of 255, similar to colours), by changing the image to be unsigned chars from the beginning, not only reduces the file size down to 6Mb (6220800 bytes)  but removes the requirement to cast any data before it is saved to a file.</p> <h5>Raytracer Optimisations</h5> <p>One of the major changes to the ray tracer was reducing the number of time the dot product is called, due to the dot product being commutable, the calculation for the dot product of raydir and hit was called 4-5 times a render, Along with this, moving the check for if you have exceeded the max trace depth to the beginning of the method removed the need to calculate multiple values that in turn would be wasted time. As you can see from [Figure 7] the improvements to the ray tracer have made the application run each frame over 2 times faster (2.26 times). Through the ray tracer, there were a lot of areas where floats and doubles were being combined, by turning all values into floats any conversions were removed</p> <h5>File IO Optimisations</h5> <p>One optimisation on file IO was to use remove the need to cast objects each save, as previously mentioned this was applied on return from the trace function, this allowed for the casting to be handled in the treads and reduced the number of calls to the ofstream each frame (reduced a call per pixel which at 1080p is 2,073,600 times). The most major improvement to the file IO, however, was to use ofstream write, we already had the image pointer full of all the data and the length of it (pixel count * 3 for RGB values), this meant we could simply pass this data to ofstream write as a buffer and therefore only call the ofstream once</p> <h5>PS4 Optimisations</h5> <p>Porting to the PS4 has been an overly successful venture, all the ray tracer improvements including all the compiler optimisations, data structure and threading optimisations were added with little difficulty. We can see from the data shown in [Figure 9] that the PS4 optimisations lead to a vast improvement of speed, when utilising all threads available the frame time increase close to 2 times faster. One issue found with the PS4 port however was due to the Devkit being accessed remotely the files were streamed back to the computer causing a small transfer delay. Due to the PS4 being run on a different OS certain features of the C++ standard library were not included by default, firstly attempting to allocate blocks of memory using the LinearAllocator on the onion bus fixed the issue of not being able to use the new and delete key words, upon further investigation of the SDK documentation I was able to include the required files and get the new and delete key words working. Attempting to implement the memory management feature caused a few problems however, one of the biggest issues was linked to the issues caused by a lack of the new and delete keyword, using the LinearAllocator allocated a block of memory like a memory pool, when attempting to free that block of memory in delete required access to the original LinearAllocator. When the LinearAllocator was replaced with new and delete this issue was removed. Another issue with the memory allocator was with the Heap Factory, for an unknown reason at certain sections of the code the Heaps allocation number along with other sections are reset to default values, the one thought on this was linked to the data being part of a static class, this could cause issues with random other sections of the code overwriting or clearing the memory block unexpectedly</p>",
        "Categories": "c++,visualstudio"
    },
    {
        "Title": "We All Die Young",
        "Subtitle": "UKIE 2018 Submission - Best game at Staffordshire University",
        "Thumbnail": "wealldieyoungmain.PNG",
        "ContentGallery" : "yt~xFz9gQKbB14,img~\\Thumbnails\\wealldieyoung.PNG",
        "ContentText": "<h4>Introduction</h4> <p>This game was created in Unity using C#. The theme of this Game Jam was \"Change\". Working in a team of 5 we set out to draw up some ideas, bouncing these ideas around we soon agreed on using change from a monetary perspective. </p> <h4>Submission Notes</h4> <p> We chose to take the theme of change in a different direction. Our idea is that you have a pocket full of different coins, in other words “change” and you then must use that as your ammunition to survive an endless wave of zombies. This tied in to having an educational aspect to it where you must shoot the correct amount of coins at the zombies to kill them. </p> <h4>The Aim</h4> <p> Playing as a stationary character, the aim of the game is to hand out the correct change to the incomming zombies. If a zombie reaches you, you lose a life. The aim is to kill the zombies by handing the correct change to them, to switch between coins simply use the 1-7 keys. The least amount of coins given in an exchange, the more points are earnt, the player cannot give more change than they have. </p> <h4>My Tasks</h4> <p> My tasks for the Game Jam was to manage the games shared data, game over, handling of scores and the in-game UI. The games shared data needed to be available to each user, due to time constraints and for simplicity I decided to use a Singleton pattern to handle all scoring and lives the player might have, being able to always access the same \"Player\" object was important. The game system handled lives, as previously mentioned these lives are gained and lost throughout the game and required easy updating, the UI would also need to show the correct number of hearts that the player had. An extra feature I worked on required the use of C# Timers, part of the scoring mechanic was how long the player could last, utilising the C# timer we were able to cleanly update the UI with second based time steps. I was able to improve my knowledge mainly on Unity's UI systems due to the amount of items we needed to display </p>",
        "Categories": "c++,ai"
    },
    {
        "Title": "Catalyst Engine",
        "Subtitle": "RTS Engine created in C++ using SDL2.",
        "Thumbnail": "CatalystLogo.bmp",
        "ContentGallery" : "",
        "ContentText": "Coming Soon",
        "Categories": "c++,sdl,visualstudio"
    },
    {
        "Title": "AI Modules",
        "Subtitle": "Coding a genetic algorithm to learn how to complete multiple levels of the 90's game Lemmings",
        "Thumbnail": "CatalystLogo.bmp",
        "ContentGallery" : "",
        "ContentText": "Coming Soon",
        "Categories": "c++,ai,visualstudio"
    },
    {
        "Title": "Icy Climber",
        "Subtitle": "Group based Android game project",
        "Thumbnail": "icyclimber.png",
        "ContentGallery" : "", 
        "ContentText": "<h4>Introduction</h4> <p>Icy Climber was an Android game developed in Love2D Lua aimed at a younger audience, the game was developed as part of a team module and was pitched infront of developers at Playground Games. </p> <iframe width='100%' height='450px' src='https://www.youtube.com/embed/Jlb6hLQqxrg' frameborder='0' allow='accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture' allowfullscreen></iframe> <h4>My Involvement</h4> <p> My main involment in this project was taking the role of Team Manager, I was in charge of the tasks that each member took part of, the Github and its commits and helped to organise group meetings. </p><p>Along with my project managment role I also helped to work on the overall games development, from discussing different ideas with the team and working out solutions for each. I also was set the main graphics design role, creating or finding copy-right free images that we could use in the game. </p> <h4>Pitching to Playground Games</h4> <p> As previously mentioned, the team was given the oportunity to go to Playground Games' Headquatres and pitch the game and its design to a few developers. The aim of the pitch was to act like it was for a new release that we aimed to recieve funding for. The pitch required each team member to present their sections of the game to the audience, showing ideas for how they would improve their section and the future plans for the game. </p> <p>Overall our game was voted to be the most complete game and we impressed in our presentation.</p> <h4>Github</h4>&nbsp;<a href='https://github.com/POYTEBUSH/IcyClimber' target='_blank'>Link</a>",
        "Categories": "c++,ai"
    },
    {
        "Title": "Rocket Ball",
        "Subtitle": "Physics in DirectX 11 C++",
        "Thumbnail": "thumb1.jpg",
        "ContentGallery" : "",
        "ContentText": "<h4>Introduction</h4> <p>I have created a game called Rocket Ball for this project and Involves the use of DirectX11 to complete many different rendering techniques and styles by passing render data between multiple shaders. The game was then improvved to handle physics and collisions to replicate a game similar to Rocket League.</p> <h4>Player Controls</h4> <ul> <li> <p>Player</p> <ul> <li> <p><kbd>W</kbd>&nbsp;Moves the car forwards with a force in relation to its mass</p> <p><kbd>A</kbd>&nbsp;Moves the car Left-ways with a force in relation to its mass</p> <p><kbd>S</kbd>&nbsp;Moves the car backwards with a force in relation to its mass</p> <p><kbd>D</kbd>&nbsp;Moves the car Right-way with a force in relation to its mass</p> <p><kbd>Space</kbd>&nbsp;Jump</p> </li> </ul> <p>Camera</p> <ul> <li> <p><kbd>1</kbd>&nbsp;Free camera controlled via the mouse</p> <p><kbd>2</kbd>&nbsp;Arena / Spectator Camera</p> <p><kbd>3</kbd>&nbsp;Follow Camera that stays behind the player</p> <p><kbd>4</kbd>&nbsp;Top Camera above the player</p> </li> </ul> <p>Acceleration</p> <ul> <li> <p><kbd>5</kbd>&nbsp;Move at constant Acceleration</p> <p><kbd>6</kbd>&nbsp;move at constant velocity</p> </li> </ul> </li> </ul> <h4>The Game</h4>> <p>This game utilises a physics system programmed in C++ using a combination of Mass Aggregate and a rigid body system to simulate a football field with extra features. Each game object in the game is assigned an Appearance (how it looks and its geometry) a Transform (where it is located in world space, its rotation and its scale) and a Particle Model which is used to apply forces and update the position and rotation in relation to them. Each particle model is initialised to have values for its acceleration and velocity along with a pointer to the game objects transform, allowing for the transformation of the object. We also pass into the particle model constructer a collision radius for spherical based collisions, a mass to allow calculation of weight in relation to gravity and a Boolean to specify  whether or not the game object is affected by gravity or not (allows for assets such as the arena to be ignored). In the constructor of this class, I also specify the flow and move type of the object that are both enums. </p> <pre> <code> enum FlowType { NOTSET, LAMINAR, TURBULENT }; enum MoveType { CONSTACCELL, CONSTVEL }; </code> </pre> <p>When the game has a certain FlowType assigned the velocity will slow down with a calculation of drag force in relation to its drag factor and the overall weight of the object. The movement type will specify the calculations for the movement / displacement of the game object each frame in relation to the net force added. At each frame I make sure that all forces are removed and the net force and acceleration are cleared. I use the method AddForce(Vector3D force) which takes in a Vector based force and will push it onto the vector stack, I then call my update for the particle model which firstly will update the momentum and position values to be correct and then assigns a gravity vector if A. it is affected by it and B. if the game objects y position is greater than 0.0f and then if the object is less than 0.05f on the y axis then a resultant force to weight is applied to simulate the effect of the object bouncing. After the gravity and resultant force is applied I then update the net force which is calculated as a vector and uses a for loop to iterate through all values in the forces vector stack and add them to the running total for the net force. This value is then used to calculate the total the acceleration of the object.</p> <p>If the move at constant acceleration is chosen then the equations S=UT + 0.5 * AT¬2 and V = U + AT which calculate the displacement and change in velocity at each frame respectively.</p> <p>The value of 0.017 is the time step that allows this calculation to be corresponding with the 60FPS lock that the game is set to. Once these two formulas are calculated I follow up by making the velocity get reduced by the drag factor which allows for the object to progressively slow down until it is fully stationary. When using move forwards at a constant velocity I simply use the method of taking the current position and adding the velocity + time step. </p> <h4>Collisions</h4> <p>I use two different collision calculations for my game, one is a Sphere to sphere and the other is a Sphere to AABB (Axis aligned bounding Box). The sphere to sphere calculation takes into account the centre position of both spheres and their radii; The calculation simply aim to check whether or not the distance between the two centre points is smaller than the radius of the sphere.</p> <p>When a game object hits the bounds of the arena the object will bound off the wall with a velocity that is the dot product of the original velocity flipped and the collision normal of the wall: object->SetVelocity(object->GetVelocity().DotProduct(Vector3D(-1.0f, 0.0f, 0.0f))); The ball and the player also collide where the velocity of the objects are set to be their current velocity – the momentum of the collider / the current objects mass. </p> <h4>My particle system works by instantiating a set number of game objects into a vector stack and then applying a similar force to them all from an emitter point, Using object pooling I am able to move the objects with the forces and then when they hit the specified max height they are moved back to the emmiter point to move again. <code> ParticleSystem(int NumOfParticles, GameObject* Particle, Vector3D startPos, float maxHeight);</code> The designer is able to pass in any already instantiated game object to the particle system along with the number of objects in the system and their max height, they can also choose between a spray effect and a fountain effect where the particles will move in a different way using the <code>void SetParticleSystemEffect(ParticleSystemType type) { mSystemType = type; };</code> Due to all of the particles being smaller game objects without colliders they are drawn in the same way to the screen and updated also. </h4>        ",
        "Categories": "c++,directx11,physics"
    }
]