[
    {
        "Title": "Final Year Project - Beliveability of AI agents",
        "Subtitle": "Exploring what approaches can be applied to AI Agents to make them appear more human.",
        "Thumbnail": "AIBase.jpg",
        "ContentGallery" : "",
        "ContentText": "<h2 class='greenunder'>Introduction</h2> <p>Artificial Intelligence in computer games is used to enhance the gameplay through increasing the population and interaction it offers to the players. This study aims to look at the approaches taken to improve Artificial intelligent (AI) human based agents such as troops in a military simulator or NPC’s in MMORPG’s. The aforementioned AI agents must follow human-like actions and approaches to issues to make them appear less robotic and pre-calculated. </p> <p> One major issue with AI Agents is that due to the complexity of their actions they are often pre-programmed to perform actions in the best possible way, this however to the human eye may not seem the smartest of options. An example of this is in path-finding where the AI agent will choose to take the shortest route without any application to forward which in comparison a human might opt to cut corners or take a longer route which in hindsight might be safer. The aim of my research is to analyse and compare different approaches made in the games industry to improve the appearance of AI agents with the aim to make them appear more like human controlled characters and less out of place </p> <p> My aim for this study is to analyse multiple techniques in order to create an AI system to play <a href='https://en.wikipedia.org/wiki/AssaultCube'>Assaulty Cube</a> which is a Free Open Source FPS game built on the <a href='http://cubeengine.com/cube.php4'>CUBE Engine</a>. </p> <p> This study is currently on-going and will be completed along side documentation and a thesis report. </p>",
        "Categories": "c++,ai,visualstudio"
    },
    {
        "Title": "Low Level Programming",
        "Subtitle": "Optimisation of a simple raytracing application with multiple low level techniques.",
        "Thumbnail": "raytracersphere.png",
        "ContentGallery" : "img~\\Thumbnails\\llfigure1.png,img~\\Thumbnails\\llfigure2.png,img~\\Thumbnails\\llfigure3.png,img~\\Thumbnails\\llfigure4.png,img~\\Thumbnails\\llfigure5.png,img~\\Thumbnails\\llfigure6.png,img~\\Thumbnails\\llfigure7.png,img~\\Thumbnails\\llfigure8.png,img~\\Thumbnails\\llfigure9.png",
        "ContentText": "<h2 class='greenunder'>Optimisations and Tabulated Data</h2> <h4>Start to End Frame Times</h4> <p>Multiple optimisations have been made to the code base of the ray tracing application to increase the speed of render. As you can see from the data shown below, in tests using two different systems with different CPUs. Both systems use 16GB of RAM and are running on a local Hard Drive. The graph [Figure 1] shows the increase overall from the starting code to the final product when run, the improvements on the i7 4770k lead to an improvement of 36.5 times faster, with the Xeon running 30.4 times faster also. </p> <h4>O0 and O2 Optimisation Levels</h4> <p> When utilising the C++ compiler settings for a release of the ray tracing applications two options were used and tested. O0 offers no optimisation improvements and O2 offers improvements to the compile which favours speed over the size of the final solution. Regardless of the system that is being used, it can be noted that using O2 compiler settings will make the system between 7-10 times faster (i7 at 9.2 times and Xeon at 7.3 times faster). </p> <h4>Floating Point Precision Optimisations</h4> <p> Using the floating point precision level of fast over the default precise as shown in Figure 4 improves the speed of the fully threaded application by around 0.2seconds for each frame, This also meant that there was no reason code any improved solution such as (Anon., n.d.) where  the speed was either the same or slightly slower. </p> <h4>Threading Optimisations</h4> <p> reading the application allowed for the system to utilise all of its resources on rendering the images, the application automatically calculates the number of threads that are available to the application and divides the screen up into that amount of chunks, this allows for each section of the render to be calculated on a different thread improving the speed drastically. The graph shown in [Figure 4] shows the vast increase in render speeds when threading is enabled, The Xeon was able to render 2.4 times faster when using all 4 cores available and the i7 3.2 times faster when using all 8 cores. It should be noticed that both CPUs architecture are over 5 years old and newer CPUs will be able to offer far improved speeds. It is also noted that the number of cores will not exponentially improve the speed of the application. .</p> <h4>Data Structure Optimisations</h4> <p>One of the optimisations that were performed on the application was to develop a templated Linked List, this allowed easier removal and adding to the list when compared to the pre-existing use of a vector, this structure was used to hold all Sphere data that was loaded in. The sphere data, in the beginning, was cleared and repopulated each frame, this allowed for a reduction in each frame time as the spheres didn’t require a recreation. The largest optimisation to the data structure, however, was re-using the Vec3f used to contain the image data, originally this data source was reinitialised each frame and then deleted, this was not necessary as once the image had been exported to a file it was no longer needed in the application, rather than deleting and recreating a clean object it was simply improved to just overwrite the original one, moving the initialisation of the object to the constructor.</p> <p>The image Vec3f was also set up as a float, when using a 1080p image it would be 24Mb (24883200 bytes) in memory size, this image object is used throughout the app to hold the colour data that is then output to a file, when the file is output each value was converted to an unsigned char (max value of 255, similar to colours), by changing the image to be unsigned chars from the beginning, not only reduces the file size down to 6Mb (6220800 bytes)  but removes the requirement to cast any data before it is saved to a file.</p> <h4>Raytracer Optimisations</h4> <p>One of the major changes to the ray tracer was reducing the number of time the dot product is called, due to the dot product being commutable, the calculation for the dot product of raydir and hit was called 4-5 times a render, Along with this, moving the check for if you have exceeded the max trace depth to the beginning of the method removed the need to calculate multiple values that in turn would be wasted time. As you can see from [Figure 7] the improvements to the ray tracer have made the application run each frame over 2 times faster (2.26 times). Through the ray tracer, there were a lot of areas where floats and doubles were being combined, by turning all values into floats any conversions were removed</p> <h4>File IO Optimisations</h4> <p>One optimisation on file IO was to use remove the need to cast objects each save, as previously mentioned this was applied on return from the trace function, this allowed for the casting to be handled in the treads and reduced the number of calls to the ofstream each frame (reduced a call per pixel which at 1080p is 2,073,600 times). The most major improvement to the file IO, however, was to use ofstream write, we already had the image pointer full of all the data and the length of it (pixel count * 3 for RGB values), this meant we could simply pass this data to ofstream write as a buffer and therefore only call the ofstream once</p> <h4>PS4 Optimisations</h4> <p>Porting to the PS4 has been an overly successful venture, all the ray tracer improvements including all the compiler optimisations, data structure and threading optimisations were added with little difficulty. We can see from the data shown in [Figure 9] that the PS4 optimisations lead to a vast improvement of speed, when utilising all threads available the frame time increase close to 2 times faster. One issue found with the PS4 port however was due to the Devkit being accessed remotely the files were streamed back to the computer causing a small transfer delay. Due to the PS4 being run on a different OS certain features of the C++ standard library were not included by default, firstly attempting to allocate blocks of memory using the LinearAllocator on the onion bus fixed the issue of not being able to use the new and delete key words, upon further investigation of the SDK documentation I was able to include the required files and get the new and delete key words working. Attempting to implement the memory management feature caused a few problems however, one of the biggest issues was linked to the issues caused by a lack of the new and delete keyword, using the LinearAllocator allocated a block of memory like a memory pool, when attempting to free that block of memory in delete required access to the original LinearAllocator. When the LinearAllocator was replaced with new and delete this issue was removed. Another issue with the memory allocator was with the Heap Factory, for an unknown reason at certain sections of the code the Heaps allocation number along with other sections are reset to default values, the one thought on this was linked to the data being part of a static class, this could cause issues with random other sections of the code overwriting or clearing the memory block unexpectedly</p>",
        "Categories": "c++,visualstudio"
    },
    {
        "Title": "Catalyst Engine",
        "Subtitle": "RTS Engine created in C++ using SDL2.",
        "Thumbnail": "CatalystLogo.bmp",
        "ContentGallery" : "",
        "ContentText": "<p class=‘western’><u><b>Introduction:</b></u></p> <p class=‘western’>I have created a game called Rocket Ball for this project and Involves the use of DirectX11 to complete many different rendering techniques and styles by passing render data between multiple shaders. The game currently features multiple aspects of these rendering techniques to make it look appealing and realistic to any customers.</p> <p class=‘western’><u><b>Player Control:</b></u></p> <ul> <li> <p class=‘western’>Moving the Car</p> <ul> <li> <p class=‘western’>The player can move the car around the scene using the arrow keys on their keyboard. The players car can move forwards and back and the left and right arrows will rotate the car in their directions.</p> </li> </ul> </li> <li> <p class=‘western’>Setting the Camera</p> <ul> <li> <p class=‘western’>As mentioned previously the player can select which camera they wish to view the game from by using the ‘1-4’ keys with the current camera and guide displayed in the windows title.</p> </li> </ul> </li> <li> <p class=‘western’>Moving the Free Camera</p> <ul> <li> <p class=‘western’>As previously mentioned the player can move the free camera forwards and backwards along its forward vector using the ‘shift’ and ‘control’ keys.</p> </li> </ul> </li> </ul> <p class=‘western’><u><b>The Window:</b></u></p> <p class=‘western’>The window is a 1920x1080 display.</p> <p class=‘western’><u><b>The Scene:</b></u></p> <p class=‘western’>In order to draw the scene I needed two main things, Something to render and something to see that render with; therefore I needed to have multiple Camera views and multiple models imported into my scene. Once these objects where in the scene I then needed to make sure that they were lighted correctly using the raw data obtained from their respective texture files which we then passes into the Pixel shaders to obtain Phong shading which should enable us a more realistic (better calculated) lighting than Goraud which is calculated in the vertex shader. I used a constant buffer to pass my initialised lighting values and locations to the shader in the Draw();.</p> <p class=‘western’><u><b>Lighting and Shading:</b></u></p> <p class=‘western’>As briefly mentioned my game uses initialised data for the lighting, when the game is initialised diffuse, ambient and specular light are all set with material and light values, light direction and specular power are also defined once. The lighting in the scene follows the current camera around the scene allowing the closest point to the player to be well lit. Each model in the scene is also assigned an Albedo, Normal and Specular texture which I can use to tell the shader how much light each object can absorb and reflect, and how they shade. My lighting values and the texture data are all passed into the constant buffer and then into the HLSL .fx file (the shader) I use the pixel shader for the lighting and combine the constant buffers data and the textures to return/output a single colour value for that pixel determining how it looks.</p> <p class=‘western’><u><b>Loading in the Assets:</b></u></p> <p class=‘western’>All of the assets that are used in my game are loaded in using an OBJ Loader. This is for the model format .obj and allows me to have more in-depth models imported into the scene. This OBJ Loader uses the vertex, vertex normal, texture coords, and faces. The data is loaded in from file as mesh data in the games init where it uses this OBJ Loader to get the mesh data, This mesh data is then passed over to a GameObject which is a class object that allows me to group multiple functions that only relate to that model e.g. getting and setting the Position and Rotation in world space coordinates via multiple Get() Set() methods. The GameObject can be manipulated in the games Update to change its location, rotation or size and the Matrixes are recalculated with the game objects UpdateWorld() function.</p> <p class=‘western’><u><b>Cameras and their Views:</b></u></p> <p class=‘western’>In my scene I have used 2 types of camera to allow the user to view the game from multiple perspectives. I have used a LookTo camera which is a camera which looks in a certain direction using a forward vector, and a LookAt camera which rather than looking in a certain direction looks at a certain object instead. All of the data similar to a GameObject is held in its own class where once all 4 cameras are initialised and set as either a LookAt or LookTo they can be mainpulated in the update again. As I have 4 camera I needed a way to make sure that the user can use one camera at a time and freely switch between them easilly, for this I created a pointer to a camera object which is what I used as the current camera that the player uses. All of the cameras are updated individually and If the user wishes to change to another camera then they are all assigned to a number key ‘1-4’. The four cameras that I have are:</p> <ul> <li> <p class=‘western’>Free Camera</p> <ul> <li> <p class=‘western’>The free camera is a LookTo camera which uses the mouses input to tell the camera where it should be looking. I then set the forward vector of the camera each time the camera is being moved to the sin and cosine values. For this camera we assign the forward vectors x to be the sin of the mouses x, the y to be the cos of y and the z to be the cos of the x value (because the mouse only moves around the 2d scene) this also allows us to make the 2d coordinates of the mouse work for the 3d game. The player can also use the ‘shift’ and ‘control’ keys to move backwards and forwards along this forward vector (they can move in the direction that they are facing).</p> </li> </ul> </li> </ul> <ul> <li> <p class=‘western’>Follow Camera</p> <ul> <li> <p class=‘western’>My follow camera simply follows the players car around the scene and is a dynamic camera that stays behind the car. This camera simply takes into account the current position and rotation of the car to create its forward vector and then puts the cameras eye always be behind the car (set the eye to the cars position -= its forward* a magnitude) and the cameras forward vector is then set to be the same as the cars so it is always looking in the same direction.</p> </li> </ul> </li> <li> <p class=‘western’>Top Down Camera</p> <ul> <li> <p class=‘western’>My top down camera simply follows the players car around the scene and dynamic as it always stays above it whilst looking do to it. This camera is a LookAt camera that uses the players car position and sets the camera eye to be the cars position but slightly raised on the Y axis so that it is always above it and apply the same rotation to the camera as what the car is using, then I simply set the cameras at to be looking at the car meaning that it would look down onto the car</p> </li> </ul> </li> <li> <p class=‘western’>Arena / Spectator Camera</p> <ul> <li> <p class=‘western’>My arena camera is a static fixed LookAt camera that sits on the wall of the cage / arena looking down onto the pitch, this one simply takes in the player’s car and its position, using that position I simply update the ‘at’ of the camera to look at the car and follow it around the scene as the player moves it.</p> </li> </ul> </li> </ul> <p class=‘western’><u><b>Skybox:</b></u></p> <p class=‘western’>My game uses the technique of cube mapping to create a skybox, A cube map is a texture file which has two texture for each coordinate (x,-x, y,-y, z,-z). I created a cube map texture and loaded it into the game the same way that I did before, I also loaded into the game an inverted and unwrapped sphere that the cube map would be applied to. I decided that I should use a separate shader for the skybox as it wouldn’t need all of the data other objects use like their lighting. I created a new vertex and pixel shader for the skybox and a new ‘.fx’ file for it. In this .fx file I take in the Cube maps texture and in the pixel shader I sample the texture and set it to be positioned so that it will always be the same distance away from the camera however far we move the camera.</p> ",
        "Categories": "c++,sdl,visualstudio"
    },
    {
        "Title": "Genetic Algorithms - Lemmings",
        "Subtitle": "Coding a genetic algorithm to learn how to complete multiple levels of the 90's game Lemmings",
        "Thumbnail": "CatalystLogo.bmp",
        "ContentGallery" : "",
        "ContentText": "<p class=‘western’><u><b>Introduction:</b></u></p> <p class=‘western’>I have created a game called Rocket Ball for this project and Involves the use of DirectX11 to complete many different rendering techniques and styles by passing render data between multiple shaders. The game currently features multiple aspects of these rendering techniques to make it look appealing and realistic to any customers.</p> <p class=‘western’><u><b>Player Control:</b></u></p> <ul> <li> <p class=‘western’>Moving the Car</p> <ul> <li> <p class=‘western’>The player can move the car around the scene using the arrow keys on their keyboard. The players car can move forwards and back and the left and right arrows will rotate the car in their directions.</p> </li> </ul> </li> <li> <p class=‘western’>Setting the Camera</p> <ul> <li> <p class=‘western’>As mentioned previously the player can select which camera they wish to view the game from by using the ‘1-4’ keys with the current camera and guide displayed in the windows title.</p> </li> </ul> </li> <li> <p class=‘western’>Moving the Free Camera</p> <ul> <li> <p class=‘western’>As previously mentioned the player can move the free camera forwards and backwards along its forward vector using the ‘shift’ and ‘control’ keys.</p> </li> </ul> </li> </ul> <p class=‘western’><u><b>The Window:</b></u></p> <p class=‘western’>The window is a 1920x1080 display.</p> <p class=‘western’><u><b>The Scene:</b></u></p> <p class=‘western’>In order to draw the scene I needed two main things, Something to render and something to see that render with; therefore I needed to have multiple Camera views and multiple models imported into my scene. Once these objects where in the scene I then needed to make sure that they were lighted correctly using the raw data obtained from their respective texture files which we then passes into the Pixel shaders to obtain Phong shading which should enable us a more realistic (better calculated) lighting than Goraud which is calculated in the vertex shader. I used a constant buffer to pass my initialised lighting values and locations to the shader in the Draw();.</p> <p class=‘western’><u><b>Lighting and Shading:</b></u></p> <p class=‘western’>As briefly mentioned my game uses initialised data for the lighting, when the game is initialised diffuse, ambient and specular light are all set with material and light values, light direction and specular power are also defined once. The lighting in the scene follows the current camera around the scene allowing the closest point to the player to be well lit. Each model in the scene is also assigned an Albedo, Normal and Specular texture which I can use to tell the shader how much light each object can absorb and reflect, and how they shade. My lighting values and the texture data are all passed into the constant buffer and then into the HLSL .fx file (the shader) I use the pixel shader for the lighting and combine the constant buffers data and the textures to return/output a single colour value for that pixel determining how it looks.</p> <p class=‘western’><u><b>Loading in the Assets:</b></u></p> <p class=‘western’>All of the assets that are used in my game are loaded in using an OBJ Loader. This is for the model format .obj and allows me to have more in-depth models imported into the scene. This OBJ Loader uses the vertex, vertex normal, texture coords, and faces. The data is loaded in from file as mesh data in the games init where it uses this OBJ Loader to get the mesh data, This mesh data is then passed over to a GameObject which is a class object that allows me to group multiple functions that only relate to that model e.g. getting and setting the Position and Rotation in world space coordinates via multiple Get() Set() methods. The GameObject can be manipulated in the games Update to change its location, rotation or size and the Matrixes are recalculated with the game objects UpdateWorld() function.</p> <p class=‘western’><u><b>Cameras and their Views:</b></u></p> <p class=‘western’>In my scene I have used 2 types of camera to allow the user to view the game from multiple perspectives. I have used a LookTo camera which is a camera which looks in a certain direction using a forward vector, and a LookAt camera which rather than looking in a certain direction looks at a certain object instead. All of the data similar to a GameObject is held in its own class where once all 4 cameras are initialised and set as either a LookAt or LookTo they can be mainpulated in the update again. As I have 4 camera I needed a way to make sure that the user can use one camera at a time and freely switch between them easilly, for this I created a pointer to a camera object which is what I used as the current camera that the player uses. All of the cameras are updated individually and If the user wishes to change to another camera then they are all assigned to a number key ‘1-4’. The four cameras that I have are:</p> <ul> <li> <p class=‘western’>Free Camera</p> <ul> <li> <p class=‘western’>The free camera is a LookTo camera which uses the mouses input to tell the camera where it should be looking. I then set the forward vector of the camera each time the camera is being moved to the sin and cosine values. For this camera we assign the forward vectors x to be the sin of the mouses x, the y to be the cos of y and the z to be the cos of the x value (because the mouse only moves around the 2d scene) this also allows us to make the 2d coordinates of the mouse work for the 3d game. The player can also use the ‘shift’ and ‘control’ keys to move backwards and forwards along this forward vector (they can move in the direction that they are facing).</p> </li> </ul> </li> </ul> <ul> <li> <p class=‘western’>Follow Camera</p> <ul> <li> <p class=‘western’>My follow camera simply follows the players car around the scene and is a dynamic camera that stays behind the car. This camera simply takes into account the current position and rotation of the car to create its forward vector and then puts the cameras eye always be behind the car (set the eye to the cars position -= its forward* a magnitude) and the cameras forward vector is then set to be the same as the cars so it is always looking in the same direction.</p> </li> </ul> </li> <li> <p class=‘western’>Top Down Camera</p> <ul> <li> <p class=‘western’>My top down camera simply follows the players car around the scene and dynamic as it always stays above it whilst looking do to it. This camera is a LookAt camera that uses the players car position and sets the camera eye to be the cars position but slightly raised on the Y axis so that it is always above it and apply the same rotation to the camera as what the car is using, then I simply set the cameras at to be looking at the car meaning that it would look down onto the car</p> </li> </ul> </li> <li> <p class=‘western’>Arena / Spectator Camera</p> <ul> <li> <p class=‘western’>My arena camera is a static fixed LookAt camera that sits on the wall of the cage / arena looking down onto the pitch, this one simply takes in the player’s car and its position, using that position I simply update the ‘at’ of the camera to look at the car and follow it around the scene as the player moves it.</p> </li> </ul> </li> </ul> <p class=‘western’><u><b>Skybox:</b></u></p> <p class=‘western’>My game uses the technique of cube mapping to create a skybox, A cube map is a texture file which has two texture for each coordinate (x,-x, y,-y, z,-z). I created a cube map texture and loaded it into the game the same way that I did before, I also loaded into the game an inverted and unwrapped sphere that the cube map would be applied to. I decided that I should use a separate shader for the skybox as it wouldn’t need all of the data other objects use like their lighting. I created a new vertex and pixel shader for the skybox and a new ‘.fx’ file for it. In this .fx file I take in the Cube maps texture and in the pixel shader I sample the texture and set it to be positioned so that it will always be the same distance away from the camera however far we move the camera.</p> ",
        "Categories": "c++,ai,visualstudio"
    },
    {
        "Title": "Rocket Ball",
        "Subtitle": "Physics in DirectX 11 C++",
        "Thumbnail": "thumb1.jpg",
        "ContentGallery" : "",
        "ContentText": "<p class=‘western’><u><b>Introduction:</b></u></p> <p class=‘western’>I have created a game called Rocket Ball for this project and Involves the use of DirectX11 to complete many different rendering techniques and styles by passing render data between multiple shaders. The game currently features multiple aspects of these rendering techniques to make it look appealing and realistic to any customers.</p> <p class=‘western’><u><b>Player Control:</b></u></p> <ul> <li> <p class=‘western’>Moving the Car</p> <ul> <li> <p class=‘western’>The player can move the car around the scene using the arrow keys on their keyboard. The players car can move forwards and back and the left and right arrows will rotate the car in their directions.</p> </li> </ul> </li> <li> <p class=‘western’>Setting the Camera</p> <ul> <li> <p class=‘western’>As mentioned previously the player can select which camera they wish to view the game from by using the ‘1-4’ keys with the current camera and guide displayed in the windows title.</p> </li> </ul> </li> <li> <p class=‘western’>Moving the Free Camera</p> <ul> <li> <p class=‘western’>As previously mentioned the player can move the free camera forwards and backwards along its forward vector using the ‘shift’ and ‘control’ keys.</p> </li> </ul> </li> </ul> <p class=‘western’><u><b>The Window:</b></u></p> <p class=‘western’>The window is a 1920x1080 display.</p> <p class=‘western’><u><b>The Scene:</b></u></p> <p class=‘western’>In order to draw the scene I needed two main things, Something to render and something to see that render with; therefore I needed to have multiple Camera views and multiple models imported into my scene. Once these objects where in the scene I then needed to make sure that they were lighted correctly using the raw data obtained from their respective texture files which we then passes into the Pixel shaders to obtain Phong shading which should enable us a more realistic (better calculated) lighting than Goraud which is calculated in the vertex shader. I used a constant buffer to pass my initialised lighting values and locations to the shader in the Draw();.</p> <p class=‘western’><u><b>Lighting and Shading:</b></u></p> <p class=‘western’>As briefly mentioned my game uses initialised data for the lighting, when the game is initialised diffuse, ambient and specular light are all set with material and light values, light direction and specular power are also defined once. The lighting in the scene follows the current camera around the scene allowing the closest point to the player to be well lit. Each model in the scene is also assigned an Albedo, Normal and Specular texture which I can use to tell the shader how much light each object can absorb and reflect, and how they shade. My lighting values and the texture data are all passed into the constant buffer and then into the HLSL .fx file (the shader) I use the pixel shader for the lighting and combine the constant buffers data and the textures to return/output a single colour value for that pixel determining how it looks.</p> <p class=‘western’><u><b>Loading in the Assets:</b></u></p> <p class=‘western’>All of the assets that are used in my game are loaded in using an OBJ Loader. This is for the model format .obj and allows me to have more in-depth models imported into the scene. This OBJ Loader uses the vertex, vertex normal, texture coords, and faces. The data is loaded in from file as mesh data in the games init where it uses this OBJ Loader to get the mesh data, This mesh data is then passed over to a GameObject which is a class object that allows me to group multiple functions that only relate to that model e.g. getting and setting the Position and Rotation in world space coordinates via multiple Get() Set() methods. The GameObject can be manipulated in the games Update to change its location, rotation or size and the Matrixes are recalculated with the game objects UpdateWorld() function.</p> <p class=‘western’><u><b>Cameras and their Views:</b></u></p> <p class=‘western’>In my scene I have used 2 types of camera to allow the user to view the game from multiple perspectives. I have used a LookTo camera which is a camera which looks in a certain direction using a forward vector, and a LookAt camera which rather than looking in a certain direction looks at a certain object instead. All of the data similar to a GameObject is held in its own class where once all 4 cameras are initialised and set as either a LookAt or LookTo they can be mainpulated in the update again. As I have 4 camera I needed a way to make sure that the user can use one camera at a time and freely switch between them easilly, for this I created a pointer to a camera object which is what I used as the current camera that the player uses. All of the cameras are updated individually and If the user wishes to change to another camera then they are all assigned to a number key ‘1-4’. The four cameras that I have are:</p> <ul> <li> <p class=‘western’>Free Camera</p> <ul> <li> <p class=‘western’>The free camera is a LookTo camera which uses the mouses input to tell the camera where it should be looking. I then set the forward vector of the camera each time the camera is being moved to the sin and cosine values. For this camera we assign the forward vectors x to be the sin of the mouses x, the y to be the cos of y and the z to be the cos of the x value (because the mouse only moves around the 2d scene) this also allows us to make the 2d coordinates of the mouse work for the 3d game. The player can also use the ‘shift’ and ‘control’ keys to move backwards and forwards along this forward vector (they can move in the direction that they are facing).</p> </li> </ul> </li> </ul> <ul> <li> <p class=‘western’>Follow Camera</p> <ul> <li> <p class=‘western’>My follow camera simply follows the players car around the scene and is a dynamic camera that stays behind the car. This camera simply takes into account the current position and rotation of the car to create its forward vector and then puts the cameras eye always be behind the car (set the eye to the cars position -= its forward* a magnitude) and the cameras forward vector is then set to be the same as the cars so it is always looking in the same direction.</p> </li> </ul> </li> <li> <p class=‘western’>Top Down Camera</p> <ul> <li> <p class=‘western’>My top down camera simply follows the players car around the scene and dynamic as it always stays above it whilst looking do to it. This camera is a LookAt camera that uses the players car position and sets the camera eye to be the cars position but slightly raised on the Y axis so that it is always above it and apply the same rotation to the camera as what the car is using, then I simply set the cameras at to be looking at the car meaning that it would look down onto the car</p> </li> </ul> </li> <li> <p class=‘western’>Arena / Spectator Camera</p> <ul> <li> <p class=‘western’>My arena camera is a static fixed LookAt camera that sits on the wall of the cage / arena looking down onto the pitch, this one simply takes in the player’s car and its position, using that position I simply update the ‘at’ of the camera to look at the car and follow it around the scene as the player moves it.</p> </li> </ul> </li> </ul> <p class=‘western’><u><b>Skybox:</b></u></p> <p class=‘western’>My game uses the technique of cube mapping to create a skybox, A cube map is a texture file which has two texture for each coordinate (x,-x, y,-y, z,-z). I created a cube map texture and loaded it into the game the same way that I did before, I also loaded into the game an inverted and unwrapped sphere that the cube map would be applied to. I decided that I should use a separate shader for the skybox as it wouldn’t need all of the data other objects use like their lighting. I created a new vertex and pixel shader for the skybox and a new ‘.fx’ file for it. In this .fx file I take in the Cube maps texture and in the pixel shader I sample the texture and set it to be positioned so that it will always be the same distance away from the camera however far we move the camera.</p> ",
        "Categories": "c++,directx11,physics"
    },
    {
        "Title": "Flappy Bird",
        "Subtitle": "LUA Group Based Project",
        "Thumbnail": "thumb1.jpg",
        "ContentGallery" : "",
        "ContentText": "&nbsp; <span style=‘text-decoration: underline;’><strong>Load Function:</strong></span> This is the section of the Code where all of my graphics, sprites, fonts and values are created. I start by loading in all of the fonts that I will need (One default size mostly used for debug and another used for scores). I then moved onto adding in the images needed for the background and assigning a quad to each of these images to specify where they will spawn in the games window and the size that they will be. Once all of the graphics are initiated I start to initialise all of the values that I shall be using. I start with creating a random seed linked to the system time to ensure as accurate randomness as possible. Then I specify my values for the game: <ul> <li>Score - Score of the player initialised to 0</li> <li>mouseclicks - Debug for the amount of mouse clicks used in game</li> <li>spacebar - Debug for the amount of space bar clicks used in game</li> <li>pipeNum - The amount of times the Pipes have past the player (gaining them a point)</li> <li>count - Used to stop spam incrementation of Score by acting as a sleep.</li> <li>movespeed - Speed that the pipes move at</li> <li>controllock - Boolean set to false at start-up, when true the controls for the character will lock causing them to drop to the ground and issue a game over.</li> </ul> <span style=‘text-decoration: underline;’><strong>Menu:</strong></span> The menu screen for my Flappy Nerd game uses different graphics that I created in Photoshop and used the mouses location and a form of collision detection to set the boundaries for the buttons. The Menu function simply runs off of a game state that is initiated at the loading of the program and whenever the game is at the game over state and the player chooses to continue. This code also shows the drawing of the buttons, I kept the background the same throughout to keep consistency and improve performance. <span style=‘text-decoration: underline;’><strong>Mouse Functionality:</strong></span> The use of a mouse to the player allowed for a increased functionality to the game. The user can use the mouse to select different options in the Menu and also click when the game is at a Game Over state to return them to the main menu so that they can start again. <b><u>Update Method:</u></b> The update method in my game was used to simply obtain the location of the mouse each tick so that the boundaries for the menu were always up to date and also as a debug feature for checking if controls were working or not. <span style=‘text-decoration: underline;’><strong>Game:</strong></span> When the game is loaded the character will immediately start to free fall towards the ground unless they tap the ‘W’ key where the sprite is slightly tweaked to give it a different look depending on if it is falling or not (Another also occurs on control lock). The pipes are set to start off the screen and the height is set from a random seed value, this occurs each time the pipe passes the player and goes off screen to the left when this happens the pipes speed will increase slightly. Each time the pipe passes the player their score is incremented once and a count value is incremented to ensure that the score will not be spammed up. The game also features functionality for collision detection with the pipes and player and the cursor which is the extra pick-up that the player can obtain which gives a score of 5 and slows down the pipes slightly making it something worth the risk to get as the game gets harder. ",
        "Categories": "lua,groupbased"
    },
    {
        "Title": "Icy Climber",
        "Subtitle": "Test Subtitle",
        "Thumbnail": "thumb1.jpg",
        "ContentGallery" : "",
        "ContentText": "Test",
        "Categories": "c++,ai"
    }
]