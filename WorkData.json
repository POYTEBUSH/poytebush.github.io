[
    {
        "Title": "Test Title",
        "Subtitle": "Test Subtitle",
        "Thumbnail": "thumb1.jpg",
        "ContentText": "<p class=‘western’><u><b>Introduction:</b></u></p> <p class=‘western’>I have created a game called Rocket Ball for this project and Involves the use of DirectX11 to complete many different rendering techniques and styles by passing render data between multiple shaders. The game currently features multiple aspects of these rendering techniques to make it look appealing and realistic to any customers.</p> <p class=‘western’><u><b>Player Control:</b></u></p> <ul> <li> <p class=‘western’>Moving the Car</p> <ul> <li> <p class=‘western’>The player can move the car around the scene using the arrow keys on their keyboard. The players car can move forwards and back and the left and right arrows will rotate the car in their directions.</p> </li> </ul> </li> <li> <p class=‘western’>Setting the Camera</p> <ul> <li> <p class=‘western’>As mentioned previously the player can select which camera they wish to view the game from by using the ‘1-4’ keys with the current camera and guide displayed in the windows title.</p> </li> </ul> </li> <li> <p class=‘western’>Moving the Free Camera</p> <ul> <li> <p class=‘western’>As previously mentioned the player can move the free camera forwards and backwards along its forward vector using the ‘shift’ and ‘control’ keys.</p> </li> </ul> </li> </ul> <p class=‘western’><u><b>The Window:</b></u></p> <p class=‘western’>The window is a 1920x1080 display.</p> <p class=‘western’><u><b>The Scene:</b></u></p> <p class=‘western’>In order to draw the scene I needed two main things, Something to render and something to see that render with; therefore I needed to have multiple Camera views and multiple models imported into my scene. Once these objects where in the scene I then needed to make sure that they were lighted correctly using the raw data obtained from their respective texture files which we then passes into the Pixel shaders to obtain Phong shading which should enable us a more realistic (better calculated) lighting than Goraud which is calculated in the vertex shader. I used a constant buffer to pass my initialised lighting values and locations to the shader in the Draw();.</p> <p class=‘western’><u><b>Lighting and Shading:</b></u></p> <p class=‘western’>As briefly mentioned my game uses initialised data for the lighting, when the game is initialised diffuse, ambient and specular light are all set with material and light values, light direction and specular power are also defined once. The lighting in the scene follows the current camera around the scene allowing the closest point to the player to be well lit. Each model in the scene is also assigned an Albedo, Normal and Specular texture which I can use to tell the shader how much light each object can absorb and reflect, and how they shade. My lighting values and the texture data are all passed into the constant buffer and then into the HLSL .fx file (the shader) I use the pixel shader for the lighting and combine the constant buffers data and the textures to return/output a single colour value for that pixel determining how it looks.</p> <p class=‘western’><u><b>Loading in the Assets:</b></u></p> <p class=‘western’>All of the assets that are used in my game are loaded in using an OBJ Loader. This is for the model format .obj and allows me to have more in-depth models imported into the scene. This OBJ Loader uses the vertex, vertex normal, texture coords, and faces. The data is loaded in from file as mesh data in the games init where it uses this OBJ Loader to get the mesh data, This mesh data is then passed over to a GameObject which is a class object that allows me to group multiple functions that only relate to that model e.g. getting and setting the Position and Rotation in world space coordinates via multiple Get() Set() methods. The GameObject can be manipulated in the games Update to change its location, rotation or size and the Matrixes are recalculated with the game objects UpdateWorld() function.</p> <p class=‘western’><u><b>Cameras and their Views:</b></u></p> <p class=‘western’>In my scene I have used 2 types of camera to allow the user to view the game from multiple perspectives. I have used a LookTo camera which is a camera which looks in a certain direction using a forward vector, and a LookAt camera which rather than looking in a certain direction looks at a certain object instead. All of the data similar to a GameObject is held in its own class where once all 4 cameras are initialised and set as either a LookAt or LookTo they can be mainpulated in the update again. As I have 4 camera I needed a way to make sure that the user can use one camera at a time and freely switch between them easilly, for this I created a pointer to a camera object which is what I used as the current camera that the player uses. All of the cameras are updated individually and If the user wishes to change to another camera then they are all assigned to a number key ‘1-4’. The four cameras that I have are:</p> <ul> <li> <p class=‘western’>Free Camera</p> <ul> <li> <p class=‘western’>The free camera is a LookTo camera which uses the mouses input to tell the camera where it should be looking. I then set the forward vector of the camera each time the camera is being moved to the sin and cosine values. For this camera we assign the forward vectors x to be the sin of the mouses x, the y to be the cos of y and the z to be the cos of the x value (because the mouse only moves around the 2d scene) this also allows us to make the 2d coordinates of the mouse work for the 3d game. The player can also use the ‘shift’ and ‘control’ keys to move backwards and forwards along this forward vector (they can move in the direction that they are facing).</p> </li> </ul> </li> </ul> <ul> <li> <p class=‘western’>Follow Camera</p> <ul> <li> <p class=‘western’>My follow camera simply follows the players car around the scene and is a dynamic camera that stays behind the car. This camera simply takes into account the current position and rotation of the car to create its forward vector and then puts the cameras eye always be behind the car (set the eye to the cars position -= its forward* a magnitude) and the cameras forward vector is then set to be the same as the cars so it is always looking in the same direction.</p> </li> </ul> </li> <li> <p class=‘western’>Top Down Camera</p> <ul> <li> <p class=‘western’>My top down camera simply follows the players car around the scene and dynamic as it always stays above it whilst looking do to it. This camera is a LookAt camera that uses the players car position and sets the camera eye to be the cars position but slightly raised on the Y axis so that it is always above it and apply the same rotation to the camera as what the car is using, then I simply set the cameras at to be looking at the car meaning that it would look down onto the car</p> </li> </ul> </li> <li> <p class=‘western’>Arena / Spectator Camera</p> <ul> <li> <p class=‘western’>My arena camera is a static fixed LookAt camera that sits on the wall of the cage / arena looking down onto the pitch, this one simply takes in the player’s car and its position, using that position I simply update the ‘at’ of the camera to look at the car and follow it around the scene as the player moves it.</p> </li> </ul> </li> </ul> <p class=‘western’><u><b>Skybox:</b></u></p> <p class=‘western’>My game uses the technique of cube mapping to create a skybox, A cube map is a texture file which has two texture for each coordinate (x,-x, y,-y, z,-z). I created a cube map texture and loaded it into the game the same way that I did before, I also loaded into the game an inverted and unwrapped sphere that the cube map would be applied to. I decided that I should use a separate shader for the skybox as it wouldn’t need all of the data other objects use like their lighting. I created a new vertex and pixel shader for the skybox and a new ‘.fx’ file for it. In this .fx file I take in the Cube maps texture and in the pixel shader I sample the texture and set it to be positioned so that it will always be the same distance away from the camera however far we move the camera.</p> ",
        "Categories": "C++, AI"
    },
    {
        "Title": "Test Title",
        "Subtitle": "Test Subtitle",
        "Thumbnail": "thumb1.jpg",
        "ContentText": "Test",
        "Categories": "C++, AI"
    },
    {
        "Title": "Test Title",
        "Subtitle": "Test Subtitle",
        "Thumbnail": "thumb1.jpg",
        "ContentText": "Test",
        "Categories": "C++, AI"
    },
    {
        "Title": "Test Title",
        "Subtitle": "Test Subtitle",
        "Thumbnail": "thumb1.jpg",
        "ContentText": "Test",
        "Categories": "C++, AI"
    },
    {
        "Title": "Test Title",
        "Subtitle": "Test Subtitle",
        "Thumbnail": "thumb1.jpg",
        "ContentText": "Test",
        "Categories": "C++, AI"
    },
    {
        "Title": "Test Title",
        "Subtitle": "Test Subtitle",
        "Thumbnail": "thumb1.jpg",
        "ContentText": "Test",
        "Categories": "C++, AI"
    },
    {
        "Title": "Test Title",
        "Subtitle": "Test Subtitle",
        "Thumbnail": "thumb1.jpg",
        "ContentText": "Test",
        "Categories": "C++, AI"
    },
    {
        "Title": "Test Title",
        "Subtitle": "Test Subtitle",
        "Thumbnail": "thumb1.jpg",
        "ContentText": "Test",
        "Categories": "C++, AI"
    }
]